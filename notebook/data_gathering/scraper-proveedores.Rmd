---
title: "R Notebook"
output: html_notebook
---

#Packages required
```{r}
#Loading required packages
library(lubridate)
library(RSelenium)
library(rvest)
library(tidyverse)
library(netstat)
library(wdman)
library(writexl)
library(readxl)
```


#Auxiliary functions

```{r}
auxiliar_encontrar_tabla<-function(driver_aux, pausa, selector){
  selector<-"#ctl00_CPH1_UCBuscarProveedor_UpdatePanel2 .col-md-12"
  Sys.sleep(pausa)
  verificacion<-driver_aux$findElement(using = "css selector", value =selector ) 
  verificacion$getElementText()[[1]]->texto_en_pantalla
  
  return(texto_en_pantalla)
  
}
```

```{r}
encontrar_tabla <- function(driver_func = remDr, pausa = 3, max_intents = 20) {
  texto_en_pantalla <- auxiliar_encontrar_tabla(driver_aux = driver_func, pausa = pausa, selector = selector)
  
  # Loop up to max_intents times if texto_en_pantalla is too short
  for (i in 1:max_intents) {
    if (nchar(texto_en_pantalla) >= 2) {
      break  # Exit the loop if the condition is met
    }
    texto_en_pantalla <- auxiliar_encontrar_tabla(driver_aux = driver_func, pausa = pausa, selector = selector)
  }
  
  return(texto_en_pantalla)
}

```




```{r}
extract_table_aux<-function(driver_aux){
  
  #Buscamos la tabla
  tabla<-driver_aux$findElements(using = "css selector", value = "td")
  #Extraemos los textos de las celdas
  texto_celdas <- sapply(tabla, function(x) x$getElementText()[[1]])
  #Elimnamos las filas que sobran
  if(any(str_detect(texto_celdas,"\n")) ){
    indice_primer_elemento_innecesario<- which(grepl("\n", texto_celdas))[1]
  texto_celdas_filtrado <- texto_celdas[1:(indice_primer_elemento_innecesario - 1)]
  }else{
    texto_celdas_filtrado<-texto_celdas
  }
  
  
  #Cheuqamos que nos quede un multiplo de 5, porque tenemos que tener 5 columnas
  if(length(texto_celdas_filtrado) %% 5 != 0){
    stop("No coincide el número de elementos extraidos con lo esperado")
  }
  
  #Buscamos cuántos registros tendríamos en la tabla
  registros<-length(texto_celdas_filtrado)/5
  
  #Transformamos los elementos extraidos a tabla nuevamente
  tipos_de_elementos<-c("cuit","ente","nombre","estado","registro")
  tibble(elemento = texto_celdas_filtrado, tipo = rep(tipos_de_elementos, times=registros), id= rep(1:registros, each = 5) ) |> 
    pivot_wider(names_from = tipo, values_from = elemento) |> 
    select(-id)->output
  

return(output)
  
}

```

```{r}
extraer_tabla <- function(driver_func = remDr, pausa = 5, max_retries = 12) {
  
  # Initial attempt
  output <- try(suppressMessages(extract_table_aux(driver_aux = driver_func)), silent = TRUE)
  
  # Retry if error occurs
  for (i in 1:max_retries) {
    if (any(class(output) != "try-error")) {
      break  # Exit the loop if extraction is successful
    }
    Sys.sleep(pausa)  # Wait before retrying
    output <- try(suppressMessages(extract_table_aux(driver_aux = driver_func)), silent = TRUE)
  }
  
  return(output)
}
```


```{r}
verificar_tabla <- function(driver_func = remDr, pausa = 3, tabla_iteracion_anterior, max_retries = 20) {
  
  # Initial attempt to extract the table
  tabla_iteracion <- try(suppressMessages(extract_table_aux(driver_aux = driver_func)), silent = TRUE)
  
  # Retry loop if the current table is identical to the previous one
  for (i in 1:max_retries) {
    if (!identical(tabla_iteracion, tabla_iteracion_anterior)) {
      
      if (any(class(tabla_iteracion) != "try-error")) {
      break  # Exit the loop if extraction is successful
    }
      
    }
    Sys.sleep(pausa)  # Wait before retrying
    tabla_iteracion <- try(suppressMessages(extract_table_aux(driver_aux = driver_func)), silent = TRUE)

  }
  
  return(tabla_iteracion)
}
```


```{r}
extract_menu_options<-function(tipo){
   url<-"https://comprar.gob.ar/PLIEGO/BuscarProveedorCiudadano.aspx"
   html_form(session(url))[[1]]->form
   
   if(tipo=="proveedor"){
   form$fields$`ctl00$CPH1$UCBuscarProveedor$DDLTipoProveedor`$options[-1]->opciones_valores
   names(opciones_valores)<-NULL
   form$fields$`ctl00$CPH1$UCBuscarProveedor$DDLTipoProveedor`$options[-1] |> names()->opciones_texto
   }else if(tipo =="estado"){
  form$fields$`ctl00$CPH1$UCBuscarProveedor$ddlEstadoProveedor`$options[-1]->opciones_valores
   names(opciones_valores)<-NULL
   form$fields$`ctl00$CPH1$UCBuscarProveedor$ddlEstadoProveedor`$options[-1] |> names()->opciones_texto
     
   }else if(tipo =="rubro"){
  form$fields$`ctl00$CPH1$UCBuscarProveedor$ddlRubro`$options[-1]->opciones_valores
   names(opciones_valores)<-NULL
   form$fields$`ctl00$CPH1$UCBuscarProveedor$ddlRubro`$options[-1] |> names()->opciones_texto
     
   }else {
    form$fields$`ctl00$CPH1$UCBuscarProveedor$ddlPais`$options[-1]->opciones_valores
    names(opciones_valores)<-NULL
    form$fields$`ctl00$CPH1$UCBuscarProveedor$ddlPais`$options[-1] |> names()->opciones_texto
     
   }
   output<-tibble(texto = opciones_texto, valores = opciones_valores)
   return(output)
}

```


```{r}
seleccionar_opcion <- function(driver,  texto){
  
option2 <- driver$findElement(using = 'xpath', value = str_c("//option[text() = '", texto, "']"))
option2$clickElement()

}
```



```{r}
extract_table_alt<-function(remDr){
  
  #Buscamos la tabla
  tabla<-remDr$findElements(using = "css selector", value = "td")
  #Extraemos los textos de las celdas
  texto_celdas <- sapply(tabla, function(x) x$getElementText()[[1]])
  #Elimnamos las filas que sobran
  indice_primer_elemento_innecesario<- which(grepl("\n", texto_celdas))[1]
  texto_celdas_filtrado <- texto_celdas[1:(indice_primer_elemento_innecesario - 1)]
  
  #Cheuqamos que nos quede un multiplo de 5, porque tenemos que tener 5 columnas
  if(length(texto_celdas_filtrado) %% 5 != 0){
    stop("No coincide el número de elementos extraidos con lo esperado")
  }
  
  #Buscamos cuántos registros tendríamos en la tabla
  registros<-length(texto_celdas_filtrado)/5
  
  #Transformamos los elementos extraidos a tabla nuevamente
  tipos_de_elementos<-c("cuit","ente","nombre","estado","registro")
  tibble(elemento = texto_celdas_filtrado, tipo = rep(tipos_de_elementos, times=registros), id= rep(1:registros, each = 5) ) |> 
    pivot_wider(names_from = tipo, values_from = elemento) |> 
    select(-id)->output
  

return(output)
  
}

```

#Main Function


```{r}
scrape_info_proveedores<-function(paginas, texto_proveedor, texto_estado, texto_pais = "Argentina", texto_provincia, texto_rubro, pausa = 60){
  url<-"https://comprar.gob.ar/PLIEGO/BuscarProveedorCiudadano.aspx"
  
  lista_tablas<-list()
  
  rD <- rsDriver(browser = c("firefox"), #specify browser type you want Selenium to open
               check = FALSE,
               port = free_port(),
               chromever = NULL,
               geckover = "0.32.0",
               verbose = FALSE, 
               iedrver = NULL) 
  
  #Navigate to url
  remDr <- rD$client
  remDr$navigate(url)
  Sys.sleep(5)
  
  #Ingresar filtros
  seleccionar_opcion(driver = remDr, texto = texto_proveedor)
  seleccionar_opcion(driver = remDr,texto = texto_estado)
  seleccionar_opcion(driver = remDr,texto = texto_rubro)
  Sys.sleep(2)
  seleccionar_opcion(driver = remDr,texto = texto_pais)
  
  Sys.sleep(2)
  seleccionar_opcion(driver = remDr,texto = texto_provincia)
  
  #Buscar button
  buscar_button<-remDr$findElement(using = "css selector", value = "#ctl00_CPH1_UCBuscarProveedor_btnBusquedaAvanzada")
  buscar_button$clickElement()
  Sys.sleep(1)
  
  #Verficiamos si existe o no una tabla para estas categorias
  texto_en_pantalla<-encontrar_tabla(driver_func =remDr )

  if(nchar(texto_en_pantalla)<2){
    rm(rD) # if necessary when rerunning
    remDr$close()
    gc()
    return(tibble(cuit = NA, ente = NA, nombre = NA, estado = NA, registro = NA))
  }else{
    
  paginas_extra<-TRUE
  i<-1
  while (paginas_extra) {
    
    #Chequear si cargo la tabla
    tabla_iteracion<-extraer_tabla(driver_func=remDr)
    
    #Si no hay tabla cortamos
    if( any(class(tabla_iteracion[[1]]) == "try-error") ){
      break
    }else{
      lista_tablas[[i]]<-tabla_iteracion
    }
   
    
    #Verificamos que efectivamente hayamos pasado de página
    if(i>1){
      if(identical(lista_tablas[[i]],lista_tablas[[i-1]])){
      	lista_tablas[[i]]<-verificar_tabla(driver_func=remDr, tabla_iteracion_anterior=lista_tablas[[i-1]])
      	if(identical(lista_tablas[[i]],lista_tablas[[i-1]])){break}else{}
      }
    }else{}
    
    boton_pagina <- try(suppressMessages(remDr$findElement(using = "css selector", value = paste0("td:nth-child(",paginas[i],") a") ) ), silent=T)
    if(class(boton_pagina) == "try-error"){
      Sys.sleep(30)
      boton_pagina <- try(suppressMessages(remDr$findElement(using = "css selector", value = paste0("td:nth-child(",paginas[i],") a") ) ), silent=T)
      if(class(boton_pagina) == "try-error"){
        paginas_extra<-FALSE
      }else{
        paginas_extra<-TRUE
        i<-i+1
        boton_pagina$clickElement()
        Sys.sleep(2)
      }
    }else{
      paginas_extra<-TRUE  
 
      i<-i+1
      boton_pagina$clickElement()
    Sys.sleep(2)
    
    }
    
  }
  
  #Close driver and trigger garbage collector
    rm(rD) # if necessary when rerunning
    remDr$close()
    gc()
    info_proveedores <- bind_rows(lista_tablas)
    return(info_proveedores)
    
  }
  
}
```



#Variables que necesitamos

```{r}
paginas<-c(2:11,rep(3:12, times = 10000))
```

```{r}
extract_menu_options(tipo = "proveedor")->tabla_menu_proveedores
extract_menu_options(tipo = "estado")->tabla_menu_estados
extract_menu_options(tipo = "pais")->tabla_menu_paises
extract_menu_options(tipo = "rubro")->tabla_menu_rubro

provincias <- c("Buenos Aires", "Ciudad Autónoma de Buenos Aires", "Catamarca", "Chaco", "Chubut", "Córdoba", "Corrientes", "Entre Rios", "Formosa", "Jujuy", "La Pampa", "La Rioja", "Mendoza", "Misiones", "Neuquen", "Rio Negro", "Salta", "San Juan", "San Luis", "Santa Cruz", "Santa Fe", "Santiago del Estero", "Tierra del Fuego", "Tucuman")
tibble(texto=provincias)->tabla_menu_provincias
tabla_argentina<-tabla_menu_paises |> filter(texto=="Argentina")


#Renombramos variables
tabla_menu_proveedores |> rename(texto_proveedor = texto)->tabla_menu_proveedores
tabla_menu_estados |> rename(texto_estado = texto)->tabla_menu_estados
tabla_argentina |> rename(texto_pais = texto)->tabla_argentina
tabla_menu_provincias |> rename(texto_provincia=texto)->tabla_menu_provincias
tabla_menu_rubro|> rename(texto_rubro=texto)->tabla_menu_rubro

#Generamos todas las combinaciones posibles
input_table <- expand.grid( rubro = tabla_menu_rubro$texto_rubro,estado=tabla_menu_estados$texto_estado,tipo_proveedor = tabla_menu_proveedores$texto_proveedor,
                             provincia = tabla_menu_provincias$texto_provincia, pais = tabla_argentina$texto_pais) |> 
  filter(estado=="Inscripto")

```


#Scrapeamos
```{r}
listado_proveedores<-list()
```

```{r}
comienzo<-1
final<-nrow(input_table)
```


```{r}

for (j in comienzo:final) {
  
  scrape_info_proveedores(paginas = paginas, 
                          texto_proveedor = input_table$tipo_proveedor[j],
                          texto_estado = input_table$estado[j],
                          texto_pais = input_table$pais[j],
                          texto_provincia = input_table$provincia[j],
                          texto_rubro = input_table$rubro[j]) |> 
    mutate(pais = input_table$pais[j],
           provincia = input_table$provincia[j],
           tipo_proveedor = input_table$tipo_proveedor[j],
           rubro = input_table$rubro[j]
    		) |> 
    mutate(iteracion =j)->listado_proveedores[[j]]
  print(j)
  
}
bind_rows(listado_proveedores) |> 
  mutate_all(str_to_upper) |> 
  mutate(registro = dmy(registro))->proveedores_df
```

